<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Tetris Musical — 6x7</title>
<style>
  :root{ --bg:#071428; --panel:#0f1724; --cell:#2b2f36; --gap:6px; }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#071428 0%, #071a2a 100%);color:#e6eefc}
  .wrap{
  max-width:1100px;
  margin:18px auto;
  padding:16px;
  display:flex;
  flex-direction:row;      /* ← fuerza horizontal */
  flex-wrap:nowrap;        /* ← evita que baje */
  align-items:flex-start;
  gap:14px;
}
  .stage{background:rgba(255,255,255,0.03);padding:12px;border-radius:12px;box-shadow:0 6px 24px rgba(2,6,23,0.6)}
  #board{display:grid;grid-template-columns:repeat(6,48px);grid-auto-rows:48px;gap:0;background:#061428;padding:12px;border-radius:8px;position:relative}
  .cell{width:48px;height:48px;border-radius:6px;background: transparent;display:flex;align-items:center;justify-content:center;font-weight:700;color:#000;user-select:none;transition:transform .18s, opacity .18s}
  .placeholder{background:#9aa3b0;color:#fff;font-weight:900}
  .hud{
  width:320px;
  min-width:320px;   /* ← clave */
  padding:12px;
  background:rgba(255,255,255,0.02);
  border-radius:8px;
}
  button, input, select{font-size:14px;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
  .controls{display:flex;flex-direction:column;gap:10px}
  .row{display:flex;gap:8px;align-items:center}
  .notes-list{display:flex;flex-direction:column;gap:6px;max-height:260px;overflow:auto}
  .note-pill{padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);display:flex;align-items:center;justify-content:space-between;gap:8px}
  .small{font-size:12px;opacity:0.85}
  .info{margin-top:10px;font-size:13px}
  .bigbtn{width:100%;padding:10px 12px}
  .score{font-size:20px;font-weight:700}
  .pill-left{display:flex;align-items:center;gap:8px}
  .note-color{width:18px;height:18px;border-radius:4px}
  .note-name{min-width:60px}
  .note-actions button{margin-left:6px}
  .footer{font-size:12px;opacity:0.8;margin-top:8px}
  /* effect when a cell is removed */
  .pop { animation: popAnim 0.42s ease forwards; }
  @keyframes popAnim { 0% { transform:scale(1); opacity:1 } 45% { transform:scale(1.3); opacity:1 } 100% { transform:scale(0); opacity:0 } }

  /* game over overlay */
  .overlay {
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,0.65);
    color:#fff;
    font-size:28px;
    font-weight:800;
    border-radius:8px;
    z-index:50;
    pointer-events:none;
    opacity:0;
    transition:opacity .24s;
  }
  .overlay.show{pointer-events:auto; opacity:1;}
  
</style>
</head>
<body>
  <div class="wrap">
    <div class="stage" style="flex:1">
      <div style="display:flex;gap:12px;align-items:center;margin-bottom:8px">
        <h3 style="margin:0">Tetris Musical</h3>
        <div class="small" style="margin-left:auto">Controles: ← → ↓ (pausa: P)</div>
      </div>
      <div id="board" aria-hidden="false"></div>
      <div id="overlay" class="overlay" aria-hidden="true">
  <div style="text-align:center">
    <div style="margin-bottom:14px">GAME OVER</div>
    <button id="restartGame" class="bigbtn">Reiniciar juego</button>
  </div>
</div>
</div> <!-- ← CIERRA .stage -->

    <aside class="hud">
      <div class="row"><div>Velocidad (ms por paso)</div><input id="speed" type="range" min="120" max="1200" value="600" style="flex:1;margin-left:8px"></div>
      <div class="row" style="margin-top:8px"><div class="score">Puntaje: <span id="score">0</span></div></div>

      <div style="height:10px"></div>
      <div class="controls">
        <button id="start" class="bigbtn">Iniciar / Reanudar</button>
        <button id="pause" class="bigbtn">Pausar</button>

        <div class="info">Notas disponibles (al tocar fondo revelan nombre y color):</div>
        <div class="notes-list" id="notesList" role="list"></div>

        <div class="info small" style="margin-top:6px">Agregar nota personalizada (nombre y archivo de audio). Si no subes audio se usará el MP3 que subas y se predecodificará.</div>
        <input id="noteName" placeholder="Nombre (ej: Do, Do#, Reb)" />
        <input id="noteFile" type="file" accept="audio/*" />
        <div class="row"><button id="addNote">Agregar nota</button><button id="resetNotes">Reset notas</button></div>

        <div class="info" style="margin-top:8px">Reglas: apila 3 o más iguales (horizontal/vertical) para eliminarlas. Tablero 6 × 7.</div>
        <div class="footer">Material didáctico elaborado por el DTI. Arturo Hernández Maldonado <strong>IEMS</strong>CDMX.</div>
      </div>
    </aside>
  </div>

<script>
/* -------------- Config -------------- */
const COLS = 6, ROWS = 7;
let speedMs = 600;
let board = []; // ROWS x COLS
const boardEl = document.getElementById('board');
const scoreEl = document.getElementById('score');
const overlayEl = document.getElementById('overlay');

let score = 0;
let falling = null;
let loopTimer = null;
let running = false;

/* -------------- Audio -------------- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const audioCache = {};       // key -> AudioBuffer
const audioBlobCache = {};   // id -> objectURL if uploaded
let currentAudioSource = null;

/* sound file names for the special sounds (you can place files in audios/) */
const SOUND_TRES = 'audios/tresEnLinea.mp3';
const SOUND_OVER = 'audios/GameOver.mp3';

/* -------------- Default notes (option A but with 3 defaults) -------------- */
const palette = ['#f87171','#fb923c','#fbbf24','#34d399','#60a5fa','#a78bfa','#f472b6','#94a3b8','#fca5a5','#fde68a','#86efac','#93c5fd'];

// keep minimal defaults (Do, Re, Mi) but user can reset or add custom
const defaultNotes = [
 ];

let notes = []; // will be populated by resetNotes()

/* -------------- Utilities -------------- */
function midiToFreq(m){ return 440 * Math.pow(2, (m - 69)/12); }

/* -------------- Notes management -------------- */
function resetNotes(){
  notes = defaultNotes.map((d,i)=>({
    name: d.name,
    midi: d.midi ?? 60,
    file: d.file ?? null,
    color: palette[i % palette.length],
    id: d.name  // we use id as key for caches when available
  }));
  renderNotesList();
  // preload happens in startAllPreload, but decode any files now as well
  preloadAllNoteFiles();
}

function addCustomNote(name, file){
  const id = name + '-' + Date.now();
  const noteObj = {
    name,
    midi: defaultNotes.find(x=>x.name.toLowerCase()===name.toLowerCase())?.midi ?? 60,
    file: null,
    color: palette[ notes.length % palette.length ],
    id
  };
  if(file){
    const objUrl = URL.createObjectURL(file);
    noteObj.file = objUrl;
    audioBlobCache[id] = objUrl;
    // decode and cache buffer
    decodeAudioFromUrl(objUrl).then(buf=>{
      audioCache[id] = buf;
    }).catch(()=>{ console.warn('No se pudo decodificar audio subido'); });
  }
  notes.push(noteObj);
  renderNotesList();
}

/* remove a note by index */
function removeNoteByIndex(index){
  if(index<0 || index>=notes.length) return;
  const note = notes[index];
  if(note.id && audioBlobCache[note.id]){
    try{ URL.revokeObjectURL(audioBlobCache[note.id]); }catch(e){}
    delete audioBlobCache[note.id];
    delete audioCache[note.id];
  }
  notes.splice(index,1);
  renderNotesList();
}

/* render notes list */
function renderNotesList(){
  const el=document.getElementById('notesList'); el.innerHTML='';
  notes.forEach((n,i)=>{
    const pill = document.createElement('div'); pill.className='note-pill';
    const left = document.createElement('div'); left.className='pill-left';
    const colorBox = document.createElement('div'); colorBox.className='note-color'; colorBox.style.background = n.color;
    const nameSpan = document.createElement('div'); nameSpan.className='note-name'; nameSpan.textContent = n.name;
    left.appendChild(colorBox); left.appendChild(nameSpan);
    pill.appendChild(left);

    const actions = document.createElement('div'); actions.className='note-actions';
    const loadBtn = document.createElement('button'); loadBtn.textContent = '▶'; loadBtn.title='Reproducir nota';
    loadBtn.onclick = ()=>{ playNoteImmediate(n); };
    const delBtn = document.createElement('button'); delBtn.textContent = '✕'; delBtn.title='Eliminar nota';
    delBtn.onclick = ()=>{ if(confirm('Eliminar nota \"'+n.name+'\"?')) removeNoteByIndex(i); };
    actions.appendChild(loadBtn); actions.appendChild(delBtn);
    pill.appendChild(actions);

    el.appendChild(pill);
  });
}

/* -------------- Board rendering -------------- */
function initBoard(){
  board = [];
  boardEl.innerHTML = '';
  boardEl.style.gridTemplateRows = `repeat(${ROWS},48px)`;
  for(let r=0;r<ROWS;r++){
    const row = [];
    for(let c=0;c<COLS;c++){
      row.push(null);
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.id = `cell-${r}-${c}`;
      boardEl.appendChild(cell);
    }
    board.push(row);
  }
  renderBoard();
}

function renderBoard(){
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const el = document.getElementById(`cell-${r}-${c}`);
      const val = board[r][c];
      el.className = 'cell';
      el.textContent = '';
      el.style.background = 'var(--cell)';
      el.style.color = '#000';
      el.style.opacity = 1;
      if(val){
  el.style.background = val.color;
  el.style.borderRadius = '10px';   // ← AQUÍ
  el.textContent = val.revealed ? val.name : '?';
  el.style.color = val.revealed ? '#021124' : '#fff';
  el.style.fontWeight = val.revealed ? 700 : 900;
}
    }
  }
  if(falling){
    const el = document.getElementById(`cell-${falling.r}-${falling.c}`);
    if(el){
      el.classList.add('placeholder');
      el.style.background = '#9aa3b0';
      el.textContent = '?';
      el.style.color = '#fff';
    }
  }
}

/* -------------- Spawn & movement -------------- */
function spawnBlock(){
  if(!notes || notes.length === 0){
    alert('No hay notas disponibles. Agrega al menos una nota para empezar.');
    running = false;
    stopLoop();
    return;
  }

  const c = Math.floor(COLS/2);
  const idx = Math.floor(Math.random()*notes.length);
  const noteRef = notes[idx];

  const noteCopy = {
    name: noteRef.name,
    color: noteRef.color,
    midi: noteRef.midi,
    file: noteRef.file,
    id: noteRef.id ?? (noteRef.name + '-' + idx)
  };

  falling = { r: 0, c, note: noteCopy, revealed:false };

  playNoteOnGenerate(noteCopy);   // ← AQUÍ

  renderBoard();
}

function canMove(r,c){ if(r<0||c<0||c>=COLS||r>=ROWS) return false; return board[r][c]===null; }

function stepDown(){
  if(!falling){ spawnBlock(); return; }
  const nextR = falling.r + 1;
  if(nextR>=ROWS || board[nextR][falling.c]){
    placeFalling();
    // after place, check game over and matches
    if(handleMatches()){
      // matches handled inside (includes chain)
    }
    // spawn next after short delay so player perceives placement
    setTimeout(()=>{ spawnBlock(); renderBoard(); }, 80);
  } else {
    falling.r = nextR;
    renderBoard();
  }
}

/* place falling into board */
function placeFalling(){
  const r = falling.r, c = falling.c;

  board[r][c] = {
    name: falling.note.name,
    color: falling.note.color,
    revealed: true,
    midi: falling.note.midi,
    file: falling.note.file,
    id: falling.note.id
  };

  if(board[0].some(x => x !== null)){
    gameOver();
  }

  falling = null;
}

/* -------------- Controls -------------- */
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft'){ move(-1); }
  if(e.key==='ArrowRight'){ move(1); }
  if(e.key==='ArrowDown'){ fastDrop(); }
  if(e.key==='p' || e.key==='P'){ togglePause(); }
});

function move(dir){
  if(!falling) return;
  const nc = falling.c + dir;
  if(nc<0 || nc>=COLS) return;
  if(board[falling.r][nc]==null){
    falling.c = nc;
    renderBoard();
  }
}

function fastDrop(){
  if(!falling) return;
  while(true){
    const nr = falling.r + 1;
    if(nr>=ROWS || board[nr][falling.c]) break;
    falling.r = nr;
  }
  placeFalling();
  handleMatches();
  spawnBlock();
  renderBoard();
}

/* -------------- Matching & gravity (with visual + sound) -------------- */
function handleMatches(){
  const toRemove = new Set();
  // horizontal
  for(let r=0;r<ROWS;r++){
    let streak = 1;
    for(let c=1;c<COLS;c++){
      const a = board[r][c-1], b = board[r][c];
      if(a && b && a.name === b.name) streak++;
      else { if(streak>=3){ for(let k=c-streak;k<c;k++) toRemove.add(`${r},${k}`); } streak=1; }
    }
    if(streak>=3){ for(let k=COLS-streak;k<COLS;k++) toRemove.add(`${r},${k}`); }
  }
  // vertical
  for(let c=0;c<COLS;c++){
    let streak = 1;
    for(let r=1;r<ROWS;r++){
      const a = board[r-1][c], b = board[r][c];
      if(a && b && a.name === b.name) streak++;
      else { if(streak>=3){ for(let k=r-streak;k<r;k++) toRemove.add(`${k},${c}`); } streak=1; }
    }
    if(streak>=3){ for(let k=ROWS-streak;k<ROWS;k++) toRemove.add(`${k},${c}`); }
  }

  if(toRemove.size===0) return false;

  // score
  score += toRemove.size * 10;
  scoreEl.textContent = score;

  // visual pop
  toRemove.forEach(key=>{
    const [r,c] = key.split(',').map(Number);
    const el = document.getElementById(`cell-${r}-${c}`);
    if(el){
      el.classList.add('pop');
    }
  });

  // play match sound (try to decode 'tres' key or SOUND_TRES)
  setTimeout(()=>{
    // remove after visual
    toRemove.forEach(key=>{
      const [r,c] = key.split(',').map(Number);
      board[r][c] = null;
      const el = document.getElementById(`cell-${r}-${c}`);
      if(el){ el.classList.remove('pop'); el.style.opacity = 0; }
    });
    applyGravity();
    renderBoard();
    // play three-in-line sound
    playSpecial('tres');
    // chain reaction
    setTimeout(()=>{ handleMatches(); }, 150);
  }, 320);

  return true;
}

function applyGravity(){
  for(let c=0;c<COLS;c++){
    let write = ROWS-1;
    for(let r=ROWS-1;r>=0;r--){
      if(board[r][c]){
        if(write !== r){
          board[write][c] = board[r][c];
          board[r][c] = null;
        }
        write--;
      }
    }
  }
}

/* -------------- Audio helpers -------------- */
function decodeAudioFromUrl(url){
  return fetch(url).then(r=>r.arrayBuffer()).then(buf=>audioCtx.decodeAudioData(buf));
}

// preload all note files and special sounds; returns a Promise resolved when done (best-effort)
function preloadAllNoteFiles(){
  const promises = [];
  // notes
  notes.forEach(n=>{
    const key = n.id ?? n.name;
    if(audioCache[key]) return;
    if(!n.file) return;
    const p = decodeAudioFromUrl(n.file).then(buf=>{
      audioCache[key] = buf;
    }).catch(err=>{
      console.warn('No se pudo precargar', n.file, err);
    });
    promises.push(p);
  });
  // specials (tres & over) - store in keys 'tres' and 'over'
  const p1 = decodeAudioFromUrl(SOUND_TRES).then(buf=>{ audioCache['tres'] = buf; }).catch(()=>{ console.warn('No se pudo precargar', SOUND_TRES); });
  const p2 = decodeAudioFromUrl(SOUND_OVER).then(buf=>{ audioCache['over'] = buf; }).catch(()=>{ console.warn('No se pudo precargar', SOUND_OVER); });
  promises.push(p1,p2);
  return Promise.all(promises);
}

function stopCurrentAudio(){
  if(currentAudioSource){
    try{ currentAudioSource.stop(); }catch(e){}
    currentAudioSource = null;
  }
}

function playBufferByKey(key){
  stopCurrentAudio();
  if(!audioCache[key]) return;
  try{
    const src = audioCtx.createBufferSource();
    src.buffer = audioCache[key];
    src.connect(audioCtx.destination);
    currentAudioSource = src;
    src.start(0);
  }catch(e){ console.warn('play error', e); }
}

function playSpecial(nameKey){
  // prefer audioCache[nameKey], fallback to file path if note has file (handled elsewhere)
  if(audioCache[nameKey]){ playBufferByKey(nameKey); return; }
  // else try SOUND_TRES or over
  if(nameKey === 'tres' && audioCache['tres']) return playBufferByKey('tres');
  if(nameKey === 'over' && audioCache['over']) return playBufferByKey('over');
}

function playNoteOnGenerate(note){
  const key = note.id ?? note.name;
  if(audioCache[key]) playBufferByKey(key);
  else if(note.file && note.file.startsWith('blob:')) {
    decodeAudioFromUrl(note.file).then(buf=>{ audioCache[key]=buf; playBufferByKey(key); }).catch(()=>{ /* no sound */ });
  } else if(note.file){
    // if file is a relative path like 'audios/do.mp3', try to decode and play
    decodeAudioFromUrl(note.file).then(buf=>{ audioCache[key]=buf; playBufferByKey(key); }).catch(()=>{ /* no sound */ });
  }
}

function playNoteOnPlace(note){
  stopCurrentAudio(); // ← clave
  const key = note.id ?? note.name;

  if(audioCache[key]){
    playBufferByKey(key);
  } else if(note.file){
    decodeAudioFromUrl(note.file).then(buf=>{
      audioCache[key] = buf;
      playBufferByKey(key);
    }).catch(()=>{});
  }
}

function playNoteImmediate(note){
  playNoteOnPlace(note);
}

/* -------------- Game over -------------- */
function gameOver(){
  overlayEl.classList.add('show');
  playSpecial('over');
  stopLoop();
  running = false;
  falling = null;
}

function restartGame(){
  // ocultar overlay
  overlayEl.classList.remove('show');

  // reset estado
  stopLoop();
  running = false;
  falling = null;
  score = 0;
  scoreEl.textContent = score;

  // limpiar tablero (no notas, no audio)
  initBoard();

  // arrancar nuevo juego
  running = true;
  startLoop();
}

/* -------------- Controls UI actions -------------- */
document.getElementById('start').addEventListener('click', async ()=>{
  // ensure preloaded before starting
  if(!window._preloaded){
    // await preload to increase chance of sounds being ready
    await startAllPreload();
  }
  if(!running){ running = true; startLoop(); }
  try{ await audioCtx.resume(); }catch(e){}
});
document.getElementById('pause').addEventListener('click', ()=>{ running = false; stopLoop(); });
document.getElementById('speed').addEventListener('input', e=>{
  speedMs = Number(e.target.value);
  if(running){ stopLoop(); startLoop(); }
});
document.getElementById('addNote').addEventListener('click', ()=>{
  const name = document.getElementById('noteName').value.trim();
  const file = document.getElementById('noteFile').files[0];
  if(!name || !file){ alert('Falta nombre o archivo'); return; }
  addCustomNote(name, file);
  document.getElementById('noteName').value = ''; document.getElementById('noteFile').value = '';
});
document.getElementById('resetNotes').addEventListener('click', ()=>{
  if(confirm('Restablecer notas por defecto?')){ resetNotes(); }
});
document.getElementById('restartGame').addEventListener('click', async ()=>{
  try{ await audioCtx.resume(); }catch(e){}
  restartGame();
});
/* -------------- Loop functions -------------- */
function startLoop(){ if(loopTimer) clearInterval(loopTimer); loopTimer = setInterval(()=>{ stepDown(); }, speedMs); }
function stopLoop(){ if(loopTimer) clearInterval(loopTimer); loopTimer = null; }
function togglePause(){ if(running) { running=false; stopLoop(); } else { running=true; startLoop(); } }

/* -------------- Preload & init sequence -------------- */
async function startAllPreload(){
  // small loader overlay inside board while loading
  if(!document.getElementById('loaderOverlay')){
    const ld = document.createElement('div');
    ld.id = 'loaderOverlay';
    ld.style= 'position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);color:#fff;font-size:18px;border-radius:8px;z-index:40';
    ld.textContent = 'Cargando sonidos...';
    boardEl.appendChild(ld);
  }
  try{
    await preloadAllNoteFiles();
  }catch(e){ console.warn('Preload error', e); }
  const ld=document.getElementById('loaderOverlay'); if(ld) { ld.textContent = 'Listo — presiona Iniciar'; setTimeout(()=>ld.remove(),700); }
  window._preloaded = true;
}

/* -------------- Init -------------- */
initBoard();
resetNotes();
startAllPreload(); // start preloading immediately but don't spawn until user clicks Start
// do not call spawnBlock() automatically; spawn happens when starting to avoid first-block-no-sound issues

window._game = { board, notes, spawnBlock, initBoard, resetNotes };

/* cleanup object URLs on unload */
window.addEventListener('beforeunload', ()=>{
  for(const k in audioBlobCache){ try{ URL.revokeObjectURL(audioBlobCache[k]); }catch(e){} }
});
</script>
</body>
</html>